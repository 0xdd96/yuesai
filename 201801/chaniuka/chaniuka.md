# 漏洞点

这道理这道题的漏洞点并不是很好找，字符串“98K-16_times scope appdd”的大小刚好是0x18，而分配存储的堆空间也是0x18。<br>
在执行kill操作时，会执行strcpy操作，此时，会多复制一个字节，恰好可以覆盖下一个堆块的size字段，从而改变堆分配

# 利用
exp中有几个地方，感觉非常的巧妙<br>
1、这里名字是从堆块（大小为0x50）的第52个字节开始写入，此处先写入4个字节，再写入一个0x21（前面堆块的大小被覆盖之后，从此处开始，后续可以看做一个0x20的一个堆块）
```
add(21, 'fish'+chr(0x21), 0x18, '/bin/sh\x00', 1)
```
这一部分的操作，主要是在改变堆块的分配，首先删除第20个，再添加第20个，是根据fastbin的FILO，交换两个指针所指向的堆块，使得可编辑的堆块靠后。
kill命令执行strcpy操作，会覆盖第21个的size字段，使其变大为0x61，那么后续在之前特殊构造的基础上自然形成了0x20的堆块。
此时还不够，由于第21个的size字段存储的还是0x18，故要先delete，再add，将size设置为0x58，此时就可以读取0x58个字节的内容，从而可以改写第21个所指向的内容。
```
    delete(20)
    add(20, 'fish'+str(20), 0x18, 'a', 1)
    kill(20,2)
    add(2, 'fish80', 0x78, 'a'*0x8, 1)
    delete(20)
    add(20, 'fish80', 0x58, 'a'*0x8, 1)
```

此题目中堆块上存储的有函数指针和堆指针，从而可以泄露，通过覆盖堆指针为特殊的值，从而可以改写got表。

这道题目，好像还有一个UAF漏洞，不知道能不能利用。
